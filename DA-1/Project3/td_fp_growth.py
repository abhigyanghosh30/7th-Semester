# -*- coding: utf-8 -*-
"""TD_FP_Growth.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18_570ikTQRLHV-J0xay5LaWz3WDv8wEN
"""

from google.colab import drive
drive.mount('/content/drive')

from collections import defaultdict
from itertools import combinations

db = set()
header=defaultdict(lambda:{'count':0,'pointers':[]})
minsup = 3

data_file = '/content/drive/My Drive/DA-1/fp_test.txt'
# data_file = '/content/drive/My Drive/DA-1/project3.txt'

with open(data_file) as f:
    for line in f.readlines():
        attrs = line.strip().split('-1')
        vals = []
        for val in  attrs[:-1]:
            x = val.strip()
            if x not in vals:
                vals.append(x)
                header[x]['count']+=1
        db.add(tuple(vals))

header = dict(header)
keys = list(header.keys())

for item in keys:
    if header[item]['count'] < minsup:
        header.pop(item)

class Node:
    def __init__(self, item=None, count=1):
        self.item = item
        self.count = count
        self.children = []
        self.parent = None
    
    def addChild(self, item,count=1):
        for child in self.children:
            if child.item == item:
                child.count+=count
                return child
        new_node = Node(item=item, count=count)
        header[item]['pointers'].append(new_node)
        self.children.append(new_node)
        new_node.parent = self
        return new_node
        
    def get_parent(self):
        return self.parents
    
    def __repr__(self):
        return repr("Item:"+str(self.item)+", Count:"+str(self.count))

    def __str__(self):
        return "Item:"+str(self.item)+", Count:"+str(self.count)

def make_tree():
    root = Node()
    for t in db:
        items = list(t)
        items = list(filter(lambda x: x in header,items)) 
        items.sort(key = lambda x: header[x]['count'])
        curr = root
        for item in range(0,len(items)):
            curr=curr.addChild(items[item])
    return root

root = make_tree()
# print( root.children[0].children[0].parent,root.children[0])

outputs = dict()
def mine_tree(X,H):
    keys = list(H.keys())
    keys.sort(key=lambda x: H[x]['count'])
    for I in keys:
        if H[I]['count']>=minsup:
            outputs[tuple([I]+X)]=H[I]['count']
            H_I = buildsubtable(I)
            mine_tree([I]+X,H_I)

def buildsubtable(I):
    H_I = defaultdict(lambda:{'count':0,'pointers':[]})

    for u in header[I]['pointers']:
        v=u.parent
        while(v.item is not None):
            v.count=0
            v=v.parent

    for u in header[I]['pointers']:
        v=u.parent
        while(v.item is not None):
            H_I[v.item]['pointers'].append(v)
            v.count=v.count+u.count
            H_I[v.item]['count']+=u.count
            v=v.parent
    return dict(H_I)

mine_tree([],header)
outputs

len(outputs)

from google.colab import drive
drive.mount('/content/drive')
import pandas as pd
from mlxtend.preprocessing import TransactionEncoder
import pyfpgrowth

dataset = []
with open(data_file) as f:
    for line in f.readlines():
        attrs = line.strip().split('-1')
        vals = set()
        for val in  attrs[:-1]:
            x = val.strip()
            vals.add(x)
        dataset.append(list(vals))

patterns = pyfpgrowth.find_frequent_patterns(dataset, minsup)
patterns

len(patterns)

